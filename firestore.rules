/**
 * @fileoverview Firestore Security Rules for the Memora application.
 *
 * Core Philosophy:
 * This ruleset prioritizes security and data ownership. It enforces a strict
 * model where users can only access their own data or data within a family
 * they belong to. The rules leverage path-based authorization for simplicity
 * and performance.
 *
 * Data Structure:
 * - /users/{userId}: Stores individual user profiles, where userId matches the
 *   Firebase Auth UID.
 * - /families/{familyId}: Stores family account information.
 * - /families/{familyId}/stories/{storyId}: Stores stories associated with a family.
 * - /families/{familyId}/memoraBoxes/{boxId}: Stores Memora Box device information
 *   associated with a family.
 * - /donatedStories/{donatedStoryId}: Stores anonymized stories for public access.
 *
 * Key Security Decisions:
 * - Users can only read and write their own user documents.
 * - Families can only be read with authorization. The admin of the family and the members can all read the family.
 * - Stories and MemoraBoxes are secured via path-based authorization, ensuring
 *   that only family members can access them.
 * - Donated stories are publicly readable but only writable by a service account.
 *
 * Denormalization for Authorization:
 * The `stories` collection will contain `familyId` field.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Users can only read and write their own profile.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their own profile if request.auth.uid == 'user123'.
     * @allow (get) User with UID 'user123' can read their own profile.
     * @allow (update) User with UID 'user123' can update their own profile.
     * @allow (delete) User with UID 'user123' can delete their own profile.
     * @deny (create) User with UID 'user456' cannot create a profile with ID 'user123'.
     * @deny (get) User with UID 'user456' cannot read the profile of user with UID 'user123'.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Secure family accounts. Family admin and members can read. Admin can write.
     * @path /families/{familyId}
     * @allow (get) User with UID 'admin123' (who is the admin) can read family 'family001'.
     * @allow (get) User with UID 'member456' (who is a member) can read family 'family001'.
     * @allow (create) User with UID 'admin123' can create family 'family001' where request.resource.data.adminId == 'admin123'.
     * @allow (update) User with UID 'admin123' can update family 'family001' where resource.data.adminId == 'admin123'.
     * @allow (delete) User with UID 'admin123' can delete family 'family001' where resource.data.adminId == 'admin123'.
     * @deny (get) User with UID 'outsider789' (who is not a member) cannot read family 'family001'.
     * @deny (create) User with UID 'member456' cannot create family 'family001' even if request.resource.data.adminId == 'admin123'.
     * @principle Enforces family ownership and membership for access control.
     */
    match /families/{familyId} {
        function isSignedIn() {
            return request.auth != null;
        }

        allow get: if isSignedIn() && (resource.data.adminId == request.auth.uid || request.auth.uid in resource.data.memberIds);
        allow list: if false;
        allow create: if isSignedIn() && request.resource.data.adminId == request.auth.uid;
        allow update: if isSignedIn() && resource.data.adminId == request.auth.uid;
        allow delete: if isSignedIn() && resource.data.adminId == request.auth.uid;
    }

    /**
     * @description Secure stories within families. Family members can read and write stories within their family.
     * @path /families/{familyId}/stories/{storyId}
     * @allow (get) User with UID 'member123' can read story 'story001' within family 'family001'.
     * @allow (list) User with UID 'member123' can list stories within family 'family001'.
     * @allow (create) User with UID 'member123' can create story 'story001' within family 'family001' where request.resource.data.familyId == 'family001'.
     * @allow (update) User with UID 'member123' can update story 'story001' within family 'family001' where resource.data.familyId == 'family001'.
     * @allow (delete) User with UID 'member123' can delete story 'story001' within family 'family001' where resource.data.familyId == 'family001'.
     * @deny (get) User with UID 'outsider456' cannot read story 'story001' within family 'family001'.
     * @deny (create) User with UID 'member123' cannot create story 'story001' with incorrect familyId.
     * @principle Enforces path-based authorization for stories within families.
     */
    match /families/{familyId}/stories/{storyId} {
        function isSignedIn() {
            return request.auth != null;
        }

        allow get: if isSignedIn() && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
        allow list: if isSignedIn() && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
        allow create: if isSignedIn() && request.resource.data.familyId == familyId && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
        allow update: if isSignedIn() && request.resource.data.familyId == familyId && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
        allow delete: if isSignedIn() && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
    }

    /**
     * @description Secure Memora Boxes within families. Family members can read and write boxes within their family.
     * @path /families/{familyId}/memoraBoxes/{boxId}
     * @allow (get) User with UID 'member123' can read box 'box001' within family 'family001'.
     * @allow (list) User with UID 'member123' can list boxes within family 'family001'.
     * @allow (create) User with UID 'member123' can create box 'box001' within family 'family001'.
     * @allow (update) User with UID 'member123' can update box 'box001' within family 'family001'.
     * @allow (delete) User with UID 'member123' can delete box 'box001' within family 'family001'.
     * @deny (get) User with UID 'outsider456' cannot read box 'box001' within family 'family001'.
     * @principle Enforces path-based authorization for Memora Boxes within families.
     */
    match /families/{familyId}/memoraBoxes/{boxId} {
        function isSignedIn() {
            return request.auth != null;
        }

        allow get: if isSignedIn() && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
        allow list: if isSignedIn() && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
        allow create: if isSignedIn() && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
        allow update: if isSignedIn() && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
        allow delete: if isSignedIn() && get(/databases/$(database)/documents/families/$(familyId)).data.memberIds.hasAny([request.auth.uid, get(/databases/$(database)/documents/families/$(familyId)).data.adminId]);
    }

    /**
     * @description Secure donated stories. Publicly readable, writable only by a service account.
     * @path /donatedStories/{donatedStoryId}
     * @allow (get) Any user can read donated story 'donated001'.
     * @allow (list) Any user can list donated stories.
     * @deny (create) Regular user cannot create donated story.
     * @deny (update) Regular user cannot update donated story.
     * @deny (delete) Regular user cannot delete donated story.
     * @principle Enforces public read access with service account-only write access for donated stories.
     */
    match /donatedStories/{donatedStoryId} {
        allow get: if true;
        allow list: if true;
        allow create: if false; // TODO: add service account check if needed.
        allow update: if false; // TODO: add service account check if needed.
        allow delete: if false; // TODO: add service account check if needed.
    }
  }
}